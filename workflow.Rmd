```{r init}
#stop('Don\'t run me dummy')
#rm(list=ls()) # clear workspace
cat('\014') # clear console
knitr::opts_chunk$set(
  eval=T
  ,include=F
)
library(tilit);library(magrittr)
'data.table' %>% ec %>% sapply(library,character.only = T) %>% invisible # load packages
data.table::setDTthreads(percent=75) # give data.table access to more than 50% cores
if(!dir.exists('d')) system('mkdir d && (cd d && mkdir q d p b)') # create data directory structure if it doesn't exist
```
# Import WOK Data

```{r wok2dbl}
# create link to original location in clean data structure 
if(!file.exists('d/p/wok2dbl.RData')) system('link Out/wok2dbl.RData d/p/wok2dbl.RData')
# Code that would generate database, but load saved data instead. Note original WOK records absent from repository.
f<-'d/p/wok2dbl.RData'
if(file.exists(f)){
  load(f)
} else {
  wok2dbl<-plagiat::wok2dbl.f(dir = 'WoS.TextFiles.19Sept2018.61551/', out = 'Out')
  save(wok2dbl,file=f)
}
wok2dbl<-unique(wok2dbl)
rm(f)
```

<!--
## WOK Descriptives

```{r descriptive}
nut<-wok2dbl[,id %>% unique %>% length]
n<-wok2dbl['CR',on='field',.N,by=val][,table(N)] %>% {data.table(N=as.integer(names(.)),nn=as.integer(.))}
n[,cs:=cumsum(nn)]
n[,cp:=round(cs/max(cs),4)]
n[,rcs:=cumsum(nn %>% rev)]
n[rcs>=180542]
n
n[,rcs:=NULL]
n
n %>% setorder(-N)
n
n[,rcs:=cumsum(nn)]
n
n[rcs>=180542]
n[rcs<180542]
wok2dbl['CR',on='field',unique(val) %>% length]

```
-->

# Bimodal edge list

```{r dbl2bel}
f<-'d/p/dbl2bel.RData'
if(file.exists(f)){
  load(f)
} else {
  dbl2bel<-plagiat::dbl2bel.f(wok2dbl,out=dirname(f),trim_doi = T,trim_anon = T,trim_loops = T,capitalize = T,trim_pendants = T) %>% invisible
  save(dbl2bel,file=f)
}
rm(f)
attributes(dbl2bel)$results
rm(wok2dbl)
dbl2bel<-unique(dbl2bel[!(pend|loop),.(ut,cr)]) %>% setkey(ut,cr)
```

# Unimodal edgelist

```{r bel2mel}
f<-'d/p/bel2mel.RData'
if(file.exists(f)){
  load(f)
} else {
  #bel2mel<-plagiat::bel2mel.f(dbl2bel,type = 'crel',out = dirname(f))
  # trim edges where weight = 1
  bel2mel<-list()
  bel2mel$crel<-pbapply::pblapply(
    split(unique(dbl2bel)[,.(ut=ut %>% unique,batch=1:ceiling((ut %>% unique %>% length)/100))][,.(ut,batch=sort(batch))],by = 'batch',keep.by = F)
    ,function(x) dbl2bel[x,data.table(do.call(rbind,lapply(1:(length(cr) - 1), function(y) matrix(cr[c(rep(y,length(cr) - y), (y + 1):length(cr))], ncol = 2)))),by = ut]
    ,cl=1
  )
  save(bel2mel,file=f)
  # bel2mel$crel %<>% rbindlist %>% setnames(old=c('V1','V2'),new=c('cr1','cr2'))
  # save(bel2mel,file=f)
  # bel2mel$crel %<>%  {.[,.(ew =.N,ut=list(ut)),keyby=.(cr1,cr2)]}
  # save(bel2mel,file=f)
  browseURL('https://hub.gke.mybinder.org/user/brooksambrose-contours-kaohkdmk/rstudio/export/bel2mel.RData?name=bel2mel.RData&file=~%2Fd%2Fp%2Fbel2mel.RData')
}
rm(f)
```

<!--
# Unimodal graph

```{r}
library(igraph)
load('Out/el.RData')
g<-graph_from_edgelist(el %>% as.matrix)
V(g)$type<-grepl('^WOS:',V(g)$name)
system.time(cg<-cluster_louvain(as.undirected(g)))
ct<-apply(cg$memberships,1,function(x) x %>% table %>% sort(decreasing = T))
View(ct)
system.time(gcr<-bipartite_projection(g,which='false'))
save(gcr,file='Out/gcr.RData')

# count 
load('Out/gcr.RData')
system.time(et<-E(gcr)$weight %>% table %>% prop.table %>% `*`(100))
cbind(round(et,4))[1:10,]

# keep only edge weights greater than 1
gcr<-subgraph.edges(gcr,which(E(gcr)$weight>1))
save(gcr,file='Out/gcr_cull.RData')

# cluster culled graph
system.time(cgr<-cluster_louvain(gcr))
save(cgr,file='Out/cgr_culled.RData')

# rename cluster ids to be in sequence by size
sm<-list()
for(i in 1:nrow(cgr$memberships)) sm[[i]]<-factor(cgr$memberships[i,],levels=order(table(cgr$memberships[i,]),decreasing = T))
sm<-do.call(data.table,sm)
setnames(sm,paste0('h',ncol(sm):1))
sm[,cr:=cgr$names]
sm[,m:=as.integer(h1)] %>% setkey(m)
```

-->