```{r init}
#stop('Don\'t run me dummy')
#rm(list=ls()) # clear workspace
cat('\014') # clear console
knitr::opts_chunk$set(
  eval=T
  ,include=F
)
library(tilit);library(magrittr)
'data.table,disk.frame' %>% ec %>% sapply(library,character.only = T) %>% invisible # load packages
data.table::setDTthreads(percent=25) # binder limits combined cpu load to 1 core's worth, so core use should be discounted
nc<-data.table::getDTthreads() # for functions asking for number of cores
{DF<-T;if(DF) {setup_disk.frame();options(future.globals.maxSize = Inf)}} # set up disk frame
if(!dir.exists('d')) system('mkdir d && (cd d && mkdir q d p b)') # create data directory structure if it doesn't exist
```
# Import WOK Data

```{r wok2dbl}
# create link to original location in clean data structure 
if(!file.exists('d/p/wok2dbl.RData')) system('link Out/wok2dbl.RData d/p/wok2dbl.RData')
# Code that would generate database, but load saved data instead. Note original WOK records absent from repository.
f<-'d/p/wok2dbl.RData'
if(file.exists(f)){
  load(f)
} else {
  wok2dbl<-plagiat::wok2dbl.f(dir = 'WoS.TextFiles.19Sept2018.61551/', out = 'Out')
  save(wok2dbl,file=f)
}
wok2dbl<-unique(wok2dbl)
rm(f)
```

```{r disk.frame-test}
wok2dfl<-as.disk.frame(wok2dbl)
mb<-microbenchmark::microbenchmark(wok2dbl['CR',on='field',.N,by=val],wok2dfl['CR',on='field',.N,by=val,keep=ec('field,val')],times=10)
pf<-profvis::profvis({

  wok2dbl['CR',on='field',.N,by=val]  
  
  wok2dfl['CR',on='field',.N,by=val,keep=ec('field,val')]
  
})
pf
```

<!--
## WOK Descriptives

```{r descriptive}
nut<-wok2dbl[,id %>% unique %>% length]
n<-wok2dbl['CR',on='field',.N,by=val][,table(N)] %>% {data.table(N=as.integer(names(.)),nn=as.integer(.))}
n[,cs:=cumsum(nn)]
n[,cp:=round(cs/max(cs),4)]
n[,rcs:=cumsum(nn %>% rev)]
n[rcs>=180542]
n
n[,rcs:=NULL]
n
n %>% setorder(-N)
n
n[,rcs:=cumsum(nn)]
n
n[rcs>=180542]
n[rcs<180542]
wok2dbl['CR',on='field',unique(val) %>% length]

```
-->

# Bimodal edge list

```{r dbl2bel}
f<-'d/p/dbl2bel.RData'
if(file.exists(f)){
  load(f)
} else {
  dbl2bel<-plagiat::dbl2bel.f(wok2dbl,out=dirname(f),trim_doi = T,trim_anon = T,trim_loops = T,capitalize = T,trim_pendants = T) %>% invisible
  save(dbl2bel,file=f)
}
rm(f)
attributes(dbl2bel)$results
rm(wok2dbl)
dbl2bel<-unique(dbl2bel[!(pend|loop),.(ut,cr)]) %>% setkey(ut,cr)
if(DF) {
  dfl2bel<-as.disk.frame(dbl2bel)
#rm(dbl2bel)
}
```

# Unimodal edgelist

```{r bel2mel}
f<-'d/p/bel2mel.RData'
if(file.exists(f)){
  load(f)
} else {
  #bel2mel<-plagiat::bel2mel.f(dbl2bel,type = 'crel',out = dirname(f))
  bel2mel<-list()
  bel2mel$crel<-pbapply::pblapply(
    split(unique(dbl2bel)[,.(ut=ut %>% unique,batch=1:ceiling((ut %>% unique %>% length)/100))][,.(ut,batch=sort(batch))],by = 'batch',keep.by = F)
    ,function(x) dbl2bel[x,data.table(do.call(rbind,lapply(1:(length(cr) - 1), function(y) matrix(cr[c(rep(y,length(cr) - y), (y + 1):length(cr))], ncol = 2)))),by = ut]
    ,cl=nc
  )
  bel2mel$crel %<>% rbindlist %>% setnames(old=c('V1','V2'),new=c('cr1','cr2'))
  bel2mel$crel %<>% {.[,.(ew =.N,ut=list(ut)),keyby=.(cr1,cr2)]}
  # trim edges where weight = 1
  new1<-bel2mel$crel[.(1),on='ew'][,.N]
  bel2mel$crel %<>% .[!.(1),on='ew']
  attr(bel2mel$crel,'results')<-data.table(case=c('ew==1','ew>=2'),N=c(new1,bel2mel$crel[,.N]))[,prop:=N/sum(N)]
  save(bel2mel,file=f)
  #browseURL('https://hub.gke.mybinder.org/user/brooksambrose-contours-p6m7z449/rstudio/export/bel2mel.RData?name=bel2mel.RData&file=~%2Fd%2Fp%2Fbel2mel.RData')
}
rm(f)
if(DF) {
  dfbel2mel<-as.disk.frame(bel2mel$crel[,!'ut'])
  attr(dfbel2mel,'results')<-attributes(bel2mel$crel)$results
#rm(dbl2bel)
}

```

<!--
# Unimodal graph

```{r}
library(igraph)
load('Out/el.RData')
g<-graph_from_edgelist(el %>% as.matrix)
V(g)$type<-grepl('^WOS:',V(g)$name)
system.time(cg<-cluster_louvain(as.undirected(g)))
ct<-apply(cg$memberships,1,function(x) x %>% table %>% sort(decreasing = T))
View(ct)
system.time(gcr<-bipartite_projection(g,which='false'))
save(gcr,file='Out/gcr.RData')

# count 
load('Out/gcr.RData')
system.time(et<-E(gcr)$weight %>% table %>% prop.table %>% `*`(100))
cbind(round(et,4))[1:10,]

# keep only edge weights greater than 1
gcr<-subgraph.edges(gcr,which(E(gcr)$weight>1))
save(gcr,file='Out/gcr_cull.RData')

# cluster culled graph
system.time(cgr<-cluster_louvain(gcr))
save(cgr,file='Out/cgr_culled.RData')

# rename cluster ids to be in sequence by size
sm<-list()
for(i in 1:nrow(cgr$memberships)) sm[[i]]<-factor(cgr$memberships[i,],levels=order(table(cgr$memberships[i,]),decreasing = T))
sm<-do.call(data.table,sm)
setnames(sm,paste0('h',ncol(sm):1))
sm[,cr:=cgr$names]
sm[,m:=as.integer(h1)] %>% setkey(m)
```

-->